<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voice Dashboard - Agent Console</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx='16' cy='16' r='15' fill='%230d1220' stroke='%23ff4444' stroke-width='1.5'/><path d='M11 12v8l6-4z' fill='%23ff4444'/><path d='M20 11a6 6 0 0 1 0 10' fill='none' stroke='%23ff4444' stroke-width='1.5' stroke-linecap='round'/><path d='M23 8.5a10 10 0 0 1 0 15' fill='none' stroke='%23ff4444' stroke-width='1.5' stroke-linecap='round' opacity='.5'/></svg>">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    height: 100%;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', sans-serif;
    -webkit-font-smoothing: antialiased;
    background: linear-gradient(135deg, #0a0d14 0%, #12151d 50%, #0a0d14 100%);
    color: #e6edf3;
  }

  body {
    display: flex;
    flex-direction: column;
  }

  /* ========== MAIN LAYOUT ========== */
  .window {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background:
      radial-gradient(ellipse at 30% 20%, rgba(255, 68, 68, 0.08) 0%, transparent 40%),
      radial-gradient(ellipse at 70% 80%, rgba(255, 68, 68, 0.05) 0%, transparent 40%),
      linear-gradient(180deg, #0a0d14 0%, #12151d 50%, #0a0d14 100%);
  }

  .content {
    flex: 1;
    padding: 24px;
    overflow: hidden;
    display: flex;
    justify-content: center;
  }

  .dashboard-grid {
    display: grid;
    grid-template-columns: 1fr 420px;
    gap: 20px;
    max-width: 1400px;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .dashboard-left, .dashboard-right {
    display: flex;
    flex-direction: column;
    gap: 20px;
    overflow: hidden;
  }

  .dashboard-left {
    min-width: 0;
  }

  /* ========== CARD STYLES ========== */
  .card {
    background: rgba(18, 21, 29, 0.6);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 16px;
    padding: 24px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  }

  .card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    padding-bottom: 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
  }

  .card-title {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.5);
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  .card-body {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }

  .card-body::-webkit-scrollbar {
    width: 6px;
  }

  .card-body::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.02);
    border-radius: 3px;
  }

  .card-body::-webkit-scrollbar-thumb {
    background: rgba(255, 68, 68, 0.3);
    border-radius: 3px;
  }

  .card-body::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 68, 68, 0.5);
  }

  /* === NOW SPEAKING CARD === */
  /* Contains: assistantTile, scrubber, transport controls */
  #nowSpeakingCard {
    min-height: 320px;
  }

  #nowSpeakingCard .card-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    overflow: visible;
  }

  .assistant {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    padding: 20px;
    width: 100%;
    transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    --glow: #ff4444;
    --glow-rgb: 255, 68, 68;
  }

  .assistant.active {
    background: rgba(255, 68, 68, 0.06);
    border-radius: 12px;
  }

  /* Portrait */
  .portrait-wrap {
    position: relative;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .portrait-wrap::before {
    content: '';
    position: absolute;
    inset: -3px;
    border-radius: 50%;
    background: conic-gradient(
      from 0deg,
      transparent 0%, var(--glow) 25%,
      transparent 50%, var(--glow) 75%,
      transparent 100%
    );
    opacity: 0;
    transition: opacity 0.5s ease;
    z-index: 0;
  }

  .portrait-wrap::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background: #0d1220;
    z-index: 0;
    transition: all 0.5s ease;
  }

  .assistant.active .portrait-wrap::before,
  .tile.active .portrait-wrap::before {
    opacity: 0.8;
    animation: spin-glow 3s linear infinite;
  }

  .assistant.active .portrait-wrap::after,
  .tile.active .portrait-wrap::after {
    inset: 2px;
  }

  .assistant.active .portrait-wrap,
  .tile.active .portrait-wrap {
    box-shadow:
      0 0 20px rgba(var(--glow-rgb), 0.4),
      0 0 50px rgba(var(--glow-rgb), 0.2),
      0 0 80px rgba(var(--glow-rgb), 0.1);
    animation: breathe 2.5s ease-in-out infinite;
  }

  @keyframes spin-glow {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @keyframes breathe {
    0%, 100% {
      box-shadow:
        0 0 20px rgba(var(--glow-rgb), 0.4),
        0 0 50px rgba(var(--glow-rgb), 0.2);
    }
    50% {
      box-shadow:
        0 0 30px rgba(var(--glow-rgb), 0.5),
        0 0 70px rgba(var(--glow-rgb), 0.25),
        0 0 100px rgba(var(--glow-rgb), 0.1);
    }
  }

  .portrait-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    position: relative;
    z-index: 1;
    transition: opacity 0.15s ease;
  }

  .mouth-closed { opacity: 1; }
  .mouth-slight { opacity: 0; position: absolute; inset: 0; }
  .mouth-open { opacity: 0; position: absolute; inset: 0; }

  .portrait-fallback {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    font-weight: 700;
    color: var(--glow);
    background: rgba(255, 255, 255, 0.03);
    border-radius: 50%;
    z-index: 1;
  }

  .voice-name {
    font-size: 16px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.9);
  }

  /* Transport Bar (moved into Now Speaking card) */
  #transportBar {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    padding: 16px 20px;
    background: rgba(255, 255, 255, 0.02);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.04);
  }

  .transport-left, .transport-right {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .transport-center {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 12px;
    min-width: 0;
  }

  #statusDot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #666;
    flex-shrink: 0;
    transition: all 0.3s ease;
  }

  #statusDot.connected {
    background: #00ff88;
    box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
  }

  #nowPlaying {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.7);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    min-width: 0;
  }

  .transport-btn, #queueToggle, #historyToggle {
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.6);
    width: 36px;
    height: 36px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    font-size: 16px;
    position: relative;
  }

  .transport-btn:hover, #queueToggle:hover, #historyToggle:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(255, 68, 68, 0.3);
    color: rgba(255, 255, 255, 0.9);
  }

  .transport-btn:active, #queueToggle:active, #historyToggle:active {
    transform: scale(0.95);
  }

  .transport-btn.disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }

  .transport-btn.disabled:hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.6);
  }

  #queueToggle.active, #historyToggle.active {
    background: rgba(255, 68, 68, 0.15);
    border-color: rgba(255, 68, 68, 0.4);
    color: #ff4444;
  }

  #queueCount {
    position: absolute;
    top: -6px;
    right: -6px;
    background: #ff4444;
    color: #fff;
    font-size: 10px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 10px;
    min-width: 18px;
    text-align: center;
    display: none;
  }

  #queueCount.visible {
    display: block;
  }

  /* Scrubber */
  #scrubber {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 12px;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  #scrubber.visible {
    opacity: 1;
    pointer-events: auto;
  }

  .scrub-time {
    font-size: 12px;
    font-family: 'SF Mono', monospace;
    color: rgba(255, 255, 255, 0.5);
    min-width: 42px;
    text-align: center;
  }

  .scrub-track {
    flex: 1;
    height: 6px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 3px;
    position: relative;
    cursor: pointer;
  }

  .scrub-fill {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    background: linear-gradient(90deg, #ff4444, #ff6666);
    border-radius: 3px;
    width: 0%;
    transition: width 0.1s linear;
  }

  .scrub-handle {
    position: absolute;
    top: 50%;
    left: 0%;
    width: 14px;
    height: 14px;
    background: #ff4444;
    border: 2px solid #fff;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    transition: left 0.1s linear;
  }

  /* === QUEUE CARD === */
  #queueCard {
    flex: 0.6;
    min-height: 200px;
  }

  #queuePanel {
    display: none;
  }

  #queuePanel.visible {
    display: block;
  }

  #queueHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
  }

  .queue-title {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.5);
  }

  #clearQueueBtn {
    background: rgba(255, 68, 68, 0.1);
    border: 1px solid rgba(255, 68, 68, 0.2);
    color: #ff4444;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  #clearQueueBtn:hover {
    background: rgba(255, 68, 68, 0.2);
    border-color: rgba(255, 68, 68, 0.4);
  }

  #queueList {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .queue-empty {
    text-align: center;
    color: rgba(255, 255, 255, 0.3);
    font-size: 14px;
    padding: 40px 20px;
  }

  .queue-item {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 8px;
    padding: 12px;
    display: flex;
    gap: 12px;
    align-items: center;
    transition: all 0.2s ease;
  }

  .queue-item:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 68, 68, 0.2);
  }

  .queue-item-voice {
    font-weight: 600;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.9);
  }

  .queue-item-text {
    flex: 1;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.5);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  #channelSection {
    margin-top: 16px;
  }

  .channel-section-label {
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.3);
    margin-bottom: 8px;
  }

  .channel-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .channel-chip {
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.6);
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .channel-chip:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(255, 68, 68, 0.2);
  }

  .channel-chip.paused {
    border-color: rgba(255, 68, 68, 0.3);
    background: rgba(255, 68, 68, 0.08);
    color: #ff4444;
  }

  .ch-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: currentColor;
  }

  .ch-icon {
    font-size: 10px;
  }

  .channel-tag {
    background: rgba(255, 68, 68, 0.15);
    color: #ff8888;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.5px;
  }

  /* === HISTORY CARD === */
  #historyCard {
    flex: 1;
    min-height: 300px;
  }

  #historyPanel {
    display: none;
  }

  #historyPanel.visible {
    display: block;
  }

  #historyHeader {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 16px;
  }

  .history-label {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.5);
  }

  .history-filters-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  #voiceFilters, #channelFilters {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .filter-chip {
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 6px;
    padding: 4px 10px;
    font-size: 11px;
    color: rgba(255, 255, 255, 0.5);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .filter-chip:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(255, 68, 68, 0.2);
  }

  .filter-chip.active {
    background: rgba(255, 68, 68, 0.15);
    border-color: rgba(255, 68, 68, 0.4);
    color: #ff4444;
  }

  #historyEmpty {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 60px 20px;
    color: rgba(255, 255, 255, 0.3);
  }

  .history-empty-icon {
    font-size: 48px;
    opacity: 0.3;
  }

  .history-empty-text {
    font-size: 14px;
  }

  #historyList {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .history-row-wrapper {
    background: rgba(255, 255, 255, 0.02);
    border: 1px solid rgba(255, 255, 255, 0.04);
    border-radius: 8px;
    padding: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .history-row-wrapper:hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: rgba(255, 68, 68, 0.2);
  }

  .history-row {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .history-row-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .history-row-voice {
    font-weight: 600;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.9);
  }

  .history-row-time {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.4);
    font-family: 'SF Mono', monospace;
  }

  .history-row-text {
    font-size: 13px;
    color: rgba(255, 255, 255, 0.5);
    line-height: 1.5;
  }

  .history-row.failed .history-row-voice {
    color: #ff4444;
  }

  .history-row.failed .history-row-text {
    text-decoration: line-through;
    opacity: 0.5;
  }

  /* === AGENTS CARD === */
  #agentsCard {
    flex: 1;
    min-height: 400px;
  }

  .grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
  }

  .tile {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 16px 12px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.02);
    border: 1px solid rgba(255, 255, 255, 0.04);
    transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    cursor: pointer;
    position: relative;
  }

  .tile:hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: rgba(255, 255, 255, 0.08);
  }

  .tile.active {
    background: rgba(var(--glow-rgb), 0.06);
    border-color: rgba(var(--glow-rgb), 0.2);
  }

  .tile .portrait-wrap {
    width: 80px;
    height: 80px;
  }

  .tile .voice-name {
    font-size: 12px;
    letter-spacing: 1px;
  }

  .status-badge {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #444;
    border: 2px solid rgba(18, 21, 29, 0.8);
  }

  .tile.active .status-badge {
    background: #ff4444;
    box-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
  }

  /* === SYSTEM CARD === */
  #systemCard {
    flex: 0 0 auto;
    min-height: auto;
  }

  #systemCard .card-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow: visible;
  }

  .system-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    font-size: 13px;
  }

  .system-label {
    color: rgba(255, 255, 255, 0.5);
    font-weight: 500;
  }

  .system-value {
    color: rgba(255, 255, 255, 0.9);
    font-weight: 600;
    font-family: 'SF Mono', monospace;
  }

  .system-status-connected {
    color: #00ff88;
  }

  .system-status-disconnected {
    color: #ff4444;
  }

  /* === TOAST === */
  #toastContainer {
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 12px;
    pointer-events: none;
  }

  .toast {
    background: rgba(18, 21, 29, 0.95);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 16px 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    min-width: 300px;
    color: #e6edf3;
    font-size: 14px;
    animation: slideIn 0.3s ease;
    pointer-events: auto;
  }

  .toast.error {
    border-left: 3px solid #ff4444;
  }

  .toast.success {
    border-left: 3px solid #00ff88;
  }

  @keyframes slideIn {
    from {
      transform: translateX(400px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  /* === MOBILE RESPONSIVE === */
  @media (max-width: 1024px) {
    .dashboard-grid {
      grid-template-columns: 1fr;
      grid-template-rows: auto auto auto auto auto;
    }

    .dashboard-left, .dashboard-right {
      overflow: visible;
    }

    #nowSpeakingCard {
      order: 1;
    }

    #queueCard {
      order: 2;
      flex: none;
      min-height: 200px;
    }

    #agentsCard {
      order: 3;
      flex: none;
      min-height: auto;
    }

    #historyCard {
      order: 4;
      flex: none;
      min-height: 300px;
    }

    #systemCard {
      order: 5;
    }

    .grid {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  @media (max-width: 640px) {
    .content {
      padding: 16px;
    }

    .dashboard-grid {
      gap: 12px;
    }

    .card {
      padding: 16px;
    }

    .grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .portrait-wrap {
      width: 100px !important;
      height: 100px !important;
    }

    .tile .portrait-wrap {
      width: 70px !important;
      height: 70px !important;
    }

    #transportBar {
      flex-wrap: wrap;
    }

    .transport-center {
      order: 3;
      width: 100%;
      margin-top: 8px;
    }
  }
</style>
</head>
<body>

<!-- ========== MAIN WINDOW ========== -->
<div class="window">
  <div class="content">
    <div class="dashboard-grid">

      <!-- ========== LEFT COLUMN ========== -->
      <div class="dashboard-left">

        <!-- NOW SPEAKING CARD -->
        <div class="card" id="nowSpeakingCard">
          <div class="card-header">
            <div class="card-title">Now Speaking</div>
          </div>
          <div class="card-body">
            <!-- Assistant Tile (Claude) -->
            <div class="assistant" id="assistantTile" data-voice="Claude">
              <div class="portrait-wrap">
                <img class="portrait-img mouth-closed" src="/portraits/claude.png" alt="Claude" draggable="false"
                     style="opacity:1">
                <img class="portrait-img mouth-slight" src="/portraits/claude_slight.png" alt="" draggable="false"
                     style="opacity:0">
                <img class="portrait-img mouth-open" src="/portraits/claude_open.png" alt="" draggable="false"
                     style="opacity:0">
              </div>
              <div class="voice-name">CLAUDE</div>
            </div>

            <!-- Scrubber -->
            <div id="scrubber">
              <span id="scrubElapsed" class="scrub-time">0:00</span>
              <div id="scrubTrack" class="scrub-track">
                <div id="scrubFill" class="scrub-fill"></div>
                <div id="scrubHandle" class="scrub-handle"></div>
              </div>
              <span id="scrubRemaining" class="scrub-time">0:00</span>
            </div>

            <!-- Transport Bar -->
            <div id="transportBar">
              <div class="transport-left">
                <button id="pauseBtn" class="transport-btn" title="Pause (Space)">
                  &#9208;
                </button>
                <button id="skipBtn" class="transport-btn disabled" title="Skip (&rarr;)">
                  &#8594;
                </button>
              </div>
              <div class="transport-center">
                <div id="statusDot"></div>
                <div id="nowPlaying">initializing...</div>
              </div>
              <div class="transport-right">
                <button id="queueToggle" title="Queue">
                  <span id="queueCount">0</span>
                  &#9776;
                </button>
                <button id="historyToggle" title="History">
                  &#128339;
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- QUEUE CARD -->
        <div class="card" id="queueCard">
          <div id="queuePanel">
            <div id="queueHeader">
              <span class="queue-title">Up Next</span>
              <button id="clearQueueBtn">Clear</button>
            </div>
            <div id="queueList">
              <div class="queue-empty">Queue empty</div>
            </div>
            <div id="channelSection"></div>
          </div>
        </div>

        <!-- HISTORY CARD -->
        <div class="card" id="historyCard">
          <div id="historyPanel">
            <div id="historyHeader">
              <span class="history-label">History</span>
              <div class="history-filters-group">
                <div id="voiceFilters"></div>
                <div id="channelFilters"></div>
              </div>
            </div>
            <div id="historyEmpty">
              <span class="history-empty-icon">&#128339;</span>
              <span class="history-empty-text">No history yet</span>
            </div>
            <div id="historyList"></div>
          </div>
        </div>

      </div>

      <!-- ========== RIGHT COLUMN ========== -->
      <div class="dashboard-right">

        <!-- AGENTS CARD -->
        <div class="card" id="agentsCard">
          <div class="card-header">
            <div class="card-title">Agents</div>
          </div>
          <div class="card-body">
            <div class="grid" id="grid"></div>
          </div>
        </div>

        <!-- SYSTEM CARD -->
        <div class="card" id="systemCard">
          <div class="card-header">
            <div class="card-title">System</div>
          </div>
          <div class="card-body">
            <div class="system-row">
              <span class="system-label">Connection</span>
              <span class="system-value system-status-disconnected" id="systemConnection">Disconnected</span>
            </div>
            <div class="system-row">
              <span class="system-label">Version</span>
              <span class="system-value">2.0</span>
            </div>
            <div class="system-row">
              <span class="system-label">Cache</span>
              <span class="system-value" id="systemCache">--</span>
            </div>
          </div>
        </div>

      </div>

    </div>
  </div>
</div>

<!-- ========== TOAST CONTAINER ========== -->
<div id="toastContainer"></div>

<script>
// ========== CONSTANTS ==========
var ASSISTANT_VOICE = 'Claude';
var VOICE_COLORS = {};
var VOICES = [];

function sanitizeColor(c) {
  if (/^#[0-9a-fA-F]{6}$/.test(c)) return c;
  if (/^#[0-9a-fA-F]{3}$/.test(c)) {
    // Expand shorthand #abc -> #aabbcc
    return '#' + c[1]+c[1] + c[2]+c[2] + c[3]+c[3];
  }
  return '#ff4444';
}

function hexToRgb(hex) {
  hex = sanitizeColor(hex);
  var r = parseInt(hex.slice(1, 3), 16);
  var g = parseInt(hex.slice(3, 5), 16);
  var b = parseInt(hex.slice(5, 7), 16);
  return r + ', ' + g + ', ' + b;
}

var ASSISTANT_TILE = document.getElementById('assistantTile');

function esc(s) {
  var d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ========== BUILD TEAM GRID ==========
var grid = document.getElementById('grid');
var tiles = {};

function buildGrid(voices) {
  // Separate assistant from team voices
  var teamVoices = voices.filter(function(v) { return v.name !== ASSISTANT_VOICE; });

  // Build color map (sanitize to prevent style injection)
  voices.forEach(function(v) {
    VOICE_COLORS[v.name] = sanitizeColor(v.color || '#ff4444');
  });

  // Update assistant tile glow color
  var assistantVoice = voices.find(function(v) { return v.name === ASSISTANT_VOICE; });
  if (assistantVoice) {
    var ac = sanitizeColor(assistantVoice.color || '#ff4444');
    ASSISTANT_TILE.style.setProperty('--glow', ac);
    ASSISTANT_TILE.style.setProperty('--glow-rgb', hexToRgb(ac));
  }

  VOICES = teamVoices;

  teamVoices.forEach(function(v) {
    var tile = document.createElement('div');
    tile.className = 'tile';
    tile.dataset.voice = v.name;

    var wrap = document.createElement('div');
    wrap.className = 'portrait-wrap';

    var img = document.createElement('img');
    img.className = 'portrait-img mouth-closed';
    img.src = '/portraits/' + v.name.toLowerCase() + '.png';
    img.alt = v.name;
    img.draggable = false;
    img.onerror = function() {
      this.style.display = 'none';
      var fb = document.createElement('div');
      fb.className = 'portrait-fallback';
      fb.textContent = v.name[0];
      wrap.appendChild(fb);
    };
    wrap.appendChild(img);

    var imgSlight = document.createElement('img');
    imgSlight.className = 'portrait-img mouth-slight';
    imgSlight.src = '/portraits/' + v.name.toLowerCase() + '_slight.png';
    imgSlight.alt = '';
    imgSlight.draggable = false;
    imgSlight.onerror = function() { this.remove(); };
    wrap.appendChild(imgSlight);

    var imgOpen = document.createElement('img');
    imgOpen.className = 'portrait-img mouth-open';
    imgOpen.src = '/portraits/' + v.name.toLowerCase() + '_open.png';
    imgOpen.alt = '';
    imgOpen.draggable = false;
    imgOpen.onerror = function() { this.remove(); };
    wrap.appendChild(imgOpen);

    var label = document.createElement('div');
    label.className = 'voice-name';
    label.textContent = v.name;

    // Status badge
    var badge = document.createElement('div');
    badge.className = 'status-badge';

    // Set tile color
    var tc = sanitizeColor(v.color || '#ff4444');
    tile.style.setProperty('--glow', tc);
    tile.style.setProperty('--glow-rgb', hexToRgb(tc));

    tile.appendChild(badge);
    tile.appendChild(wrap);
    tile.appendChild(label);
    grid.appendChild(tile);
    tiles[v.name] = tile;
  });

  // Portrait click â†’ open history filtered by voice
  ASSISTANT_TILE.style.cursor = 'pointer';
  ASSISTANT_TILE.addEventListener('click', function() {
    if (window.History) {
      window.History.filterByVoice('Claude');
      window.History.setVisible(true);
      window.Transport.setHistoryToggleActive(true);
    }
  });

  teamVoices.forEach(function(v) {
    var tile = tiles[v.name];
    if (tile) {
      tile.style.cursor = 'pointer';
      tile.addEventListener('click', function() {
        if (window.History) {
          window.History.filterByVoice(v.name);
          window.History.setVisible(true);
          window.Transport.setHistoryToggleActive(true);
        }
      });
    }
  });
}

// Fetch voice list from server, fall back to empty grid
fetch('/voices')
  .then(function(r) { return r.json(); })
  .then(function(data) { buildGrid(data); })
  .catch(function() { buildGrid([]); });

// ========== MOUTH ELEMENT CACHE ==========
var mouthElements = {};

function getMouthElements(voiceName) {
  if (mouthElements[voiceName]) return mouthElements[voiceName];
  var container;
  if (voiceName === ASSISTANT_VOICE) {
    container = ASSISTANT_TILE;
  } else {
    container = tiles[voiceName];
  }
  if (!container) return null;
  var slight = container.querySelector('.mouth-slight');
  var open = container.querySelector('.mouth-open');
  if (!slight && !open) return null;
  mouthElements[voiceName] = { slight: slight, open: open };
  return mouthElements[voiceName];
}

// ========== LIPSYNC CONTROLLER ==========
var LipSync = {
  envelope: null,
  chunkMs: 50,
  startTime: 0,
  startDelay: 80,
  activeVoice: null,
  smoothedAmp: 0,
  rafId: null,
  lastTickTime: 0,
  openMs: 0,
  closingUntil: 0,
  _paused: false,
  _pauseTime: 0,

  start: function(voiceName, envelope, chunkMs) {
    this.stop();
    if (!envelope || !envelope.length) return;
    this.envelope = envelope;
    this.chunkMs = chunkMs || 50;
    this.activeVoice = voiceName;
    this.smoothedAmp = 0;
    this.lastTickTime = 0;
    this.openMs = 0;
    this.closingUntil = 0;
    this.startTime = performance.now() + this.startDelay;
    this.rafId = requestAnimationFrame(this.tick.bind(this));
  },

  tick: function(now) {
    var elapsed = (now - this.startTime) / 1000;
    if (elapsed < 0) {
      this.rafId = requestAnimationFrame(this.tick.bind(this));
      return;
    }
    var dt = this.lastTickTime ? now - this.lastTickTime : 16;
    this.lastTickTime = now;
    var chunkSec = this.chunkMs / 1000;
    var idx = Math.floor(elapsed / chunkSec);
    if (!this.envelope || idx >= this.envelope.length) {
      this.setMouth(this.activeVoice, 0);
      return;
    }
    var frac = (elapsed / chunkSec) - idx;
    var a = this.envelope[idx];
    var b = this.envelope[Math.min(idx + 1, this.envelope.length - 1)];
    var rawAmp = a + (b - a) * frac;
    var alpha = rawAmp > this.smoothedAmp ? 0.4 : 0.15;
    this.smoothedAmp += (rawAmp - this.smoothedAmp) * alpha;
    var finalAmp = this.smoothedAmp;
    if (finalAmp > 0.2) {
      this.openMs += dt;
    } else {
      this.openMs = 0;
    }
    if (this.openMs > 350 && !this.closingUntil) {
      this.closingUntil = now + 120;
      this.openMs = 0;
    }
    if (this.closingUntil) {
      if (now < this.closingUntil) {
        var progress = 1 - (this.closingUntil - now) / 120;
        finalAmp *= 1 - 0.85 * Math.sin(progress * Math.PI);
      } else {
        this.closingUntil = 0;
      }
    }
    this.setMouth(this.activeVoice, finalAmp);
    this.rafId = requestAnimationFrame(this.tick.bind(this));
  },

  setMouth: function(voiceName, amp) {
    var els = getMouthElements(voiceName);
    if (!els) return;
    if (amp < 0.03) {
      if (els.slight) els.slight.style.opacity = 0;
      if (els.open) els.open.style.opacity = 0;
    } else if (amp < 0.15) {
      if (els.slight) els.slight.style.opacity = (amp - 0.03) / 0.12;
      if (els.open) els.open.style.opacity = 0;
    } else if (amp < 0.35) {
      if (els.slight) els.slight.style.opacity = 1 - (amp - 0.15) / 0.20;
      if (els.open) els.open.style.opacity = (amp - 0.15) / 0.20;
    } else {
      if (els.slight) els.slight.style.opacity = 0;
      if (els.open) els.open.style.opacity = 1;
    }
  },

  switchVoice: function(newVoice) {
    if (this.activeVoice) this.setMouth(this.activeVoice, 0);
    this.activeVoice = newVoice;
  },

  pause: function() {
    if (this._paused || !this.envelope) return;
    this._paused = true;
    this._pauseTime = performance.now();
    if (this.rafId) cancelAnimationFrame(this.rafId);
    this.rafId = null;
    if (this.activeVoice) this.setMouth(this.activeVoice, 0);
  },

  resume: function() {
    if (!this._paused || !this.envelope) return;
    var pauseDuration = performance.now() - this._pauseTime;
    this.startTime += pauseDuration;
    this._paused = false;
    this._pauseTime = 0;
    this.lastTickTime = 0;
    this.rafId = requestAnimationFrame(this.tick.bind(this));
  },

  stop: function() {
    if (this.rafId) cancelAnimationFrame(this.rafId);
    this.rafId = null;
    this._paused = false;
    this._pauseTime = 0;
    if (this.activeVoice) this.setMouth(this.activeVoice, 0);
    this.activeVoice = null;
    this.envelope = null;
    this.openMs = 0;
    this.closingUntil = 0;
    this.lastTickTime = 0;
  }
};

// ========== ACTIVE VOICE MANAGEMENT ==========
var activeTimeouts = [];
var currentEventId = null;
var _timeoutMeta = [];
var _pausedAt = 0;

function clearActive() {
  activeTimeouts.forEach(function(t) { clearTimeout(t); });
  activeTimeouts = [];
  _timeoutMeta = [];
  _pausedAt = 0;
  LipSync.stop();
  Object.values(tiles).forEach(function(t) { t.classList.remove('active'); });
  ASSISTANT_TILE.classList.remove('active');
}

function pauseAllTimeouts() {
  if (_pausedAt) return;
  _pausedAt = Date.now();
  var newMeta = [];
  for (var i = 0; i < _timeoutMeta.length; i++) {
    var m = _timeoutMeta[i];
    if (m.fired) {
      newMeta.push(m);
      continue;
    }
    clearTimeout(activeTimeouts[i]);
    var remaining = m.fireAt - _pausedAt;
    m.remaining = remaining;
    newMeta.push(m);
  }
  _timeoutMeta = newMeta;
  LipSync.pause();
}

function resumeAllTimeouts() {
  if (!_pausedAt) return;
  var now = Date.now();
  var pauseDuration = now - _pausedAt;
  _pausedAt = 0;
  var newTimeouts = [];
  var newMeta = [];
  for (var i = 0; i < _timeoutMeta.length; i++) {
    var m = _timeoutMeta[i];
    if (m.fired) {
      newTimeouts.push(activeTimeouts[i]);
      newMeta.push(m);
      continue;
    }
    var delay = m.remaining;
    if (delay < 0) delay = 0;
    var tid = setTimeout(m.callback, delay);
    newTimeouts.push(tid);
    m.fireAt = now + delay;
    delete m.remaining;
    newMeta.push(m);
  }
  activeTimeouts = newTimeouts;
  _timeoutMeta = newMeta;
  LipSync.resume();
}

function setActive(voiceName, envelope, durationMs, eventId) {
  clearActive();
  currentEventId = eventId;
  if (voiceName === ASSISTANT_VOICE) ASSISTANT_TILE.classList.add('active');
  else if (tiles[voiceName]) tiles[voiceName].classList.add('active');

  if (envelope && envelope.length) {
    LipSync.start(voiceName, envelope, 50);
  }

  if (durationMs && durationMs > 0) {
    var now = Date.now();
    var tid = setTimeout(function() { clearActive(); }, durationMs);
    activeTimeouts.push(tid);
    _timeoutMeta.push({ fireAt: now + durationMs, callback: function() { clearActive(); }, fired: false });
  }
}

function removeActive(voiceName) {
  if (voiceName === ASSISTANT_VOICE) ASSISTANT_TILE.classList.remove('active');
  else if (tiles[voiceName]) tiles[voiceName].classList.remove('active');
}

// ========== TRANSPORT & QUEUE ==========
window.Transport = (function() {
  var pauseBtn = document.getElementById('pauseBtn');
  var skipBtn = document.getElementById('skipBtn');
  var statusDot = document.getElementById('statusDot');
  var nowPlaying = document.getElementById('nowPlaying');
  var queueToggle = document.getElementById('queueToggle');
  var queueCount = document.getElementById('queueCount');
  var historyToggle = document.getElementById('historyToggle');
  var queuePanel = document.getElementById('queuePanel');
  var queueList = document.getElementById('queueList');
  var clearQueueBtn = document.getElementById('clearQueueBtn');

  var isPaused = false;
  var queueState = { playing: false, queued: 0, total: 0, items: [], paused: false, channel_paused: [] };
  var lastPlayState = null;

  var channelSection = document.getElementById('channelSection');

  function setNowPlaying(text) {
    nowPlaying.textContent = text;
  }

  function setQueueCount(n) {
    queueCount.textContent = n;
    if (n > 0) {
      queueCount.classList.add('visible');
    } else {
      queueCount.classList.remove('visible');
    }
  }

  function setSkipEnabled(enabled) {
    if (enabled) {
      skipBtn.classList.remove('disabled');
    } else {
      skipBtn.classList.add('disabled');
    }
  }

  function setPauseIcon(paused) {
    pauseBtn.innerHTML = paused ? '&#9654;' : '&#9208;';
    pauseBtn.title = paused ? 'Resume (Space)' : 'Pause (Space)';
  }

  function setQueueToggleActive(active) {
    if (active) queueToggle.classList.add('active');
    else queueToggle.classList.remove('active');
  }

  function setHistoryToggleActive(active) {
    if (active) historyToggle.classList.add('active');
    else historyToggle.classList.remove('active');
  }

  pauseBtn.addEventListener('click', function() {
    fetch('/queue/pause', { method: 'POST' })
      .then(function(r) { return r.json(); })
      .then(function(data) {
        isPaused = data.paused;
        setPauseIcon(isPaused);
        if (isPaused) pauseAllTimeouts();
        else resumeAllTimeouts();
      })
      .catch(function(err) { console.error('Pause failed:', err); });
  });

  skipBtn.addEventListener('click', function() {
    if (skipBtn.classList.contains('disabled')) return;
    fetch('/queue/skip', { method: 'POST' })
      .then(function(r) { return r.json(); })
      .catch(function(err) { console.error('Skip failed:', err); });
  });

  document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if (e.key === ' ' || e.code === 'Space') {
      e.preventDefault();
      pauseBtn.click();
    }
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      skipBtn.click();
    }
  });

  queueToggle.addEventListener('click', function() {
    var isVisible = queuePanel.classList.contains('visible');
    if (isVisible) {
      queuePanel.classList.remove('visible');
      setQueueToggleActive(false);
    } else {
      queuePanel.classList.add('visible');
      setQueueToggleActive(true);
      if (window.History) {
        window.History.setVisible(false);
        setHistoryToggleActive(false);
      }
    }
  });

  historyToggle.addEventListener('click', function() {
    if (!window.History) return;
    var isVisible = window.History.isVisible();
    if (isVisible) {
      window.History.setVisible(false);
      setHistoryToggleActive(false);
    } else {
      window.History.setVisible(true);
      setHistoryToggleActive(true);
      queuePanel.classList.remove('visible');
      setQueueToggleActive(false);
    }
  });

  clearQueueBtn.addEventListener('click', function() {
    if (confirm('Clear entire queue?')) {
      fetch('/queue/clear', { method: 'POST' })
        .then(function(r) { return r.json(); })
        .catch(function(err) { console.error('Clear failed:', err); });
    }
  });

  function updateQueueUI(state) {
    queueState = state;
    setQueueCount(state.queued);
    setSkipEnabled(state.playing);
    setPauseIcon(state.paused);

    if (state.items && state.items.length > 0) {
      var html = '';
      state.items.forEach(function(item) {
        var voice = esc(item.voice || 'Unknown');
        var text = esc(item.text_preview || '');
        var channel = item.channel ? ' <span class="channel-tag">' + esc(item.channel) + '</span>' : '';
        html += '<div class="queue-item">';
        html += '<div class="queue-item-voice">' + voice + channel + '</div>';
        html += '<div class="queue-item-text">' + text + '</div>';
        html += '</div>';
      });
      queueList.innerHTML = html;
    } else {
      queueList.innerHTML = '<div class="queue-empty">Queue empty</div>';
    }

    var channels = state.channel_paused || [];
    if (channels.length > 0) {
      channelSection.innerHTML = '<div class="channel-section-label">Channels</div><div class="channel-chips" id="channelChips"></div>';
      var chipsEl = document.getElementById('channelChips');
      channels.forEach(function(ch) {
        var isPaused = ch.paused;
        var btn = document.createElement('button');
        btn.className = 'channel-chip' + (isPaused ? ' paused' : '');
        btn.innerHTML = '<span class="ch-dot"></span>' + esc(ch.channel) + '<span class="ch-icon">' + (isPaused ? '\u25b6' : '\u23f8') + '</span>';
        btn.addEventListener('click', function() {
          fetch('/queue/pause?channel=' + encodeURIComponent(ch.channel), { method: 'POST' })
            .then(function(r) { return r.json(); })
            .catch(function(err) { console.error('Channel pause failed:', err); });
        });
        chipsEl.appendChild(btn);
      });
    } else {
      channelSection.innerHTML = '';
    }
  }

  return {
    setNowPlaying: setNowPlaying,
    setQueueCount: setQueueCount,
    setSkipEnabled: setSkipEnabled,
    setPauseIcon: setPauseIcon,
    setQueueToggleActive: setQueueToggleActive,
    setHistoryToggleActive: setHistoryToggleActive,
    updateQueueUI: updateQueueUI,
    getLastPlayState: function() { return lastPlayState; },
    setLastPlayState: function(s) { lastPlayState = s; }
  };
})();

// ========== HISTORY ==========
window.History = (function() {
  var panel = document.getElementById('historyPanel');
  var filterContainer = document.getElementById('channelFilters');
  var list = document.getElementById('historyList');
  var emptyState = document.getElementById('historyEmpty');
  var toastContainer = document.getElementById('toastContainer');

  var entries = [];
  var selectedVoice = null;
  var selectedChannel = null;

  function setVisible(visible) {
    if (visible) {
      panel.classList.add('visible');
    } else {
      panel.classList.remove('visible');
    }
  }

  function isVisible() {
    return panel.classList.contains('visible');
  }

  function render() {
    var filtered = entries;
    if (selectedVoice) {
      filtered = filtered.filter(function(e) { return e.voice === selectedVoice; });
    }
    if (selectedChannel) {
      filtered = filtered.filter(function(e) { return e.channel === selectedChannel; });
    }

    if (filtered.length === 0) {
      emptyState.style.display = 'flex';
      list.innerHTML = '';
      return;
    }

    emptyState.style.display = 'none';
    var html = '';
    filtered.forEach(function(entry) {
      var voice = esc(entry.voice || 'Unknown');
      var text = esc(entry.text || '');
      var ts = entry.completed_at || Date.now();
      var timeStr = formatRelativeTime(ts);
      var failedClass = entry.failed ? ' failed' : '';
      var channel = entry.channel ? ' <span class="channel-tag">' + esc(entry.channel) + '</span>' : '';

      html += '<div class="history-row-wrapper" data-id="' + esc(entry.id) + '">';
      html += '  <div class="history-row' + failedClass + '">';
      html += '    <div class="history-row-top">';
      html += '      <div class="history-row-voice">' + voice + channel + '</div>';
      html += '      <div class="history-row-time" data-ts="' + ts + '">' + timeStr + '</div>';
      html += '    </div>';
      html += '    <div class="history-row-text">' + text + '</div>';
      html += '  </div>';
      html += '</div>';
    });
    list.innerHTML = html;

    var wrappers = list.querySelectorAll('.history-row-wrapper');
    wrappers.forEach(function(wrapper) {
      wrapper.addEventListener('click', function() {
        var id = wrapper.dataset.id;
        fetch('/history/' + encodeURIComponent(id) + '/replay', { method: 'POST' })
          .then(function(r) { return r.json(); })
          .then(function(data) {
            showToast('Replaying: ' + (data.voice || 'Unknown'), 'success');
          })
          .catch(function(err) {
            showToast('Replay failed', 'error');
          });
      });
    });
  }

  function formatRelativeTime(ts) {
    var diff = Date.now() - ts;
    var sec = Math.floor(diff / 1000);
    if (sec < 60) return sec + 's ago';
    var min = Math.floor(sec / 60);
    if (min < 60) return min + 'm ago';
    var hr = Math.floor(min / 60);
    if (hr < 24) return hr + 'h ago';
    var day = Math.floor(hr / 24);
    return day + 'd ago';
  }

  function updateHistory(data) {
    entries = data.entries || [];
    render();
    updateVoiceFilters();
    updateChannelFilters();
  }

  function updateVoiceFilters() {
    var voiceFiltersEl = document.getElementById('voiceFilters');
    var voices = [];
    entries.forEach(function(e) {
      if (e.voice && voices.indexOf(e.voice) === -1) {
        voices.push(e.voice);
      }
    });
    if (voices.length === 0) {
      voiceFiltersEl.innerHTML = '';
      return;
    }
    var html = '';
    voices.forEach(function(v) {
      var active = selectedVoice === v ? ' active' : '';
      html += '<button class="filter-chip' + active + '" data-voice="' + esc(v) + '">' + esc(v) + '</button>';
    });
    voiceFiltersEl.innerHTML = html;

    voiceFiltersEl.querySelectorAll('.filter-chip').forEach(function(btn) {
      btn.addEventListener('click', function() {
        var voice = btn.dataset.voice;
        if (selectedVoice === voice) {
          selectedVoice = null;
        } else {
          selectedVoice = voice;
        }
        render();
        updateVoiceFilters();
      });
    });
  }

  function updateChannelFilters() {
    var channels = [];
    entries.forEach(function(e) {
      if (e.channel && channels.indexOf(e.channel) === -1) {
        channels.push(e.channel);
      }
    });
    if (channels.length === 0) {
      filterContainer.innerHTML = '';
      return;
    }
    var html = '';
    channels.forEach(function(ch) {
      var active = selectedChannel === ch ? ' active' : '';
      html += '<button class="filter-chip' + active + '" data-channel="' + esc(ch) + '">' + esc(ch) + '</button>';
    });
    filterContainer.innerHTML = html;

    filterContainer.querySelectorAll('.filter-chip').forEach(function(btn) {
      btn.addEventListener('click', function() {
        var channel = btn.dataset.channel;
        if (selectedChannel === channel) {
          selectedChannel = null;
        } else {
          selectedChannel = channel;
        }
        render();
        updateChannelFilters();
      });
    });
  }

  function filterByVoice(voice) {
    selectedVoice = voice;
    selectedChannel = null;
    render();
    updateVoiceFilters();
    updateChannelFilters();
  }

  function showToast(message, type) {
    var toast = document.createElement('div');
    toast.className = 'toast ' + (type || '');
    toast.textContent = message;
    toastContainer.appendChild(toast);
    setTimeout(function() {
      toast.remove();
    }, 3000);
  }

  setInterval(function() {
    list.querySelectorAll('.history-row-time[data-ts]').forEach(function(el) {
      var ts = parseInt(el.dataset.ts, 10);
      el.textContent = formatRelativeTime(ts);
    });
  }, 10000);

  return {
    setVisible: setVisible,
    isVisible: isVisible,
    updateHistory: updateHistory,
    filterByVoice: filterByVoice
  };
})();

// ========== SCRUBBER ==========
window.Scrubber = (function() {
  var scrubber = document.getElementById('scrubber');
  var track = document.getElementById('scrubTrack');
  var fill = document.getElementById('scrubFill');
  var handle = document.getElementById('scrubHandle');
  var elapsedEl = document.getElementById('scrubElapsed');
  var remainingEl = document.getElementById('scrubRemaining');

  var duration = 0;
  var isDragging = false;
  var isVisible = false;

  function show() {
    scrubber.classList.add('visible');
    isVisible = true;
  }

  function hide() {
    scrubber.classList.remove('visible');
    isVisible = false;
    duration = 0;
    fill.style.width = '0%';
    handle.style.left = '0%';
    elapsedEl.textContent = '0:00';
    remainingEl.textContent = '0:00';
  }

  function setDuration(dur) {
    duration = dur;
    if (duration > 0) {
      show();
    } else {
      hide();
    }
  }

  function update(elapsed) {
    if (duration <= 0 || isDragging) return;
    var pct = Math.min((elapsed / duration) * 100, 100);
    fill.style.width = pct + '%';
    handle.style.left = pct + '%';
    elapsedEl.textContent = formatTime(elapsed);
    remainingEl.textContent = '-' + formatTime(duration - elapsed);
  }

  function formatTime(sec) {
    var m = Math.floor(sec / 60);
    var s = Math.floor(sec % 60);
    return m + ':' + (s < 10 ? '0' : '') + s;
  }

  function seek(pct) {
    if (duration <= 0) return;
    var time = (pct / 100) * duration;
    fetch('/queue/seek?time=' + time, { method: 'POST' })
      .then(function(r) { return r.json(); })
      .catch(function(err) { console.error('Seek failed:', err); });
  }

  track.addEventListener('mousedown', function(e) {
    isDragging = true;
    var rect = track.getBoundingClientRect();
    var pct = ((e.clientX - rect.left) / rect.width) * 100;
    pct = Math.max(0, Math.min(100, pct));
    fill.style.width = pct + '%';
    handle.style.left = pct + '%';
  });

  document.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    var rect = track.getBoundingClientRect();
    var pct = ((e.clientX - rect.left) / rect.width) * 100;
    pct = Math.max(0, Math.min(100, pct));
    fill.style.width = pct + '%';
    handle.style.left = pct + '%';
  });

  document.addEventListener('mouseup', function(e) {
    if (!isDragging) return;
    isDragging = false;
    var rect = track.getBoundingClientRect();
    var pct = ((e.clientX - rect.left) / rect.width) * 100;
    pct = Math.max(0, Math.min(100, pct));
    seek(pct);
  });

  return {
    show: show,
    hide: hide,
    setDuration: setDuration,
    update: update
  };
})();

// ========== SSE CONNECTION ==========
(function() {
  var es = new EventSource('/events');
  var systemConnection = document.getElementById('systemConnection');

  es.onopen = function() {
    statusDot.classList.add('connected');
    systemConnection.textContent = 'Connected';
    systemConnection.className = 'system-value system-status-connected';
  };

  es.onerror = function() {
    statusDot.classList.remove('connected');
    systemConnection.textContent = 'Disconnected';
    systemConnection.className = 'system-value system-status-disconnected';
  };

  es.addEventListener('init', function(e) {
    var data = JSON.parse(e.data);
    Transport.updateQueueUI(data.queue);
    History.updateHistory(data.history);
    if (data.queue.playing && data.last_play_state) {
      var state = data.last_play_state;
      Transport.setLastPlayState(state);
      var voice = state.voice || 'Unknown';
      var text = state.text_preview || '';
      var channel = state.channel || null;
      var label = voice;
      if (channel) label += ' (' + channel + ')';
      Transport.setNowPlaying(label + ': ' + text);
      if (state.duration) {
        Scrubber.setDuration(state.duration);
      }
    } else {
      Transport.setNowPlaying('idle');
      Scrubber.hide();
    }
  });

  es.addEventListener('queue_update', function(e) {
    var data = JSON.parse(e.data);
    Transport.updateQueueUI(data);
  });

  es.addEventListener('voice_active', function(e) {
    var data = JSON.parse(e.data);
    var voice = data.voice || 'Unknown';
    var text = data.text_preview || '';
    var envelope = data.envelope || [];
    var duration = data.duration || 0;
    var channel = data.channel || null;
    var eventId = data.event_id || null;

    Transport.setLastPlayState(data);

    var label = voice;
    if (channel) label += ' (' + channel + ')';
    Transport.setNowPlaying(label + ': ' + text);

    var durationMs = duration ? duration * 1000 : 0;
    setActive(voice, envelope, durationMs, eventId);

    if (duration > 0) {
      Scrubber.setDuration(duration);
      var startTime = Date.now();
      var updateInterval = setInterval(function() {
        if (!Transport.getLastPlayState() || Transport.getLastPlayState().event_id !== eventId) {
          clearInterval(updateInterval);
          return;
        }
        var elapsed = (Date.now() - startTime) / 1000;
        Scrubber.update(elapsed);
        if (elapsed >= duration) {
          clearInterval(updateInterval);
        }
      }, 100);
    } else {
      Scrubber.hide();
    }
  });

  es.addEventListener('idle', function(e) {
    clearActive();
    Transport.setNowPlaying('idle');
    Transport.setLastPlayState(null);
    Scrubber.hide();
  });

  es.addEventListener('history_update', function(e) {
    var data = JSON.parse(e.data);
    History.updateHistory(data);
  });

  es.addEventListener('pause_state', function(e) {
    var data = JSON.parse(e.data);
    Transport.setPauseIcon(data.paused);
    if (data.paused) pauseAllTimeouts();
    else resumeAllTimeouts();
  });
})();

// ========== SYSTEM INFO ==========
(function() {
  var systemCache = document.getElementById('systemCache');

  function updateCacheInfo() {
    fetch('/health')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        if (data.cache_size !== undefined) {
          systemCache.textContent = formatBytes(data.cache_size);
        }
      })
      .catch(function() {});
  }

  function formatBytes(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }

  updateCacheInfo();
  setInterval(updateCacheInfo, 30000);
})();
</script>

</body>
</html>
